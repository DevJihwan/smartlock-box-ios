# SmartLockBox iOS 빌드 오류 수정 기록
**날짜:** 2025년 11월 1일  
**작업자:** DevJihwan with Claude

---

## 📋 목차
1. [개요](#개요)
2. [수정된 파일 목록](#수정된-파일-목록)
3. [상세 수정 내역](#상세-수정-내역)
4. [주요 개선사항](#주요-개선사항)
5. [빌드 결과](#빌드-결과)

---

## 개요

SmartLockBox iOS 앱의 빌드 오류를 전면 수정하고 코드 구조를 개선했습니다. 주요 문제는 deprecated API 사용, 누락된 중앙 상태 관리 클래스, 타입 불일치, 그리고 복잡한 SwiftUI 표현식으로 인한 컴파일러 타임아웃이었습니다.

### 초기 상태
- ❌ 빌드 실패 (다수의 컴파일 오류)
- ❌ AppStateManager 누락
- ❌ Deprecated Screen Time API 사용
- ❌ 타입 불일치 오류

### 최종 상태
- ✅ 빌드 성공
- ✅ 중앙화된 상태 관리 구현
- ✅ 최신 API 사용
- ✅ 타입 안정성 확보

---

## 수정된 파일 목록

### 새로 생성
1. **SmartLockBox/Managers/AppStateManager.swift**

### 수정됨
1. **SmartLockBox/Managers/ScreenTimeManager.swift**
2. **SmartLockBox/Views/MainView.swift**
3. **SmartLockBox/Views/SettingsView.swift**
4. **SmartLockBox/Views/LockScreenView.swift**
5. **SmartLockBox/Views/UnlockChallengeView.swift**
6. **SmartLockBox/ContentView.swift**
7. **SmartLockBox/ViewModels/MainViewModel.swift**

---

## 상세 수정 내역

### 1️⃣ ScreenTimeManager.swift
**커밋:** `403e5446` - "Fix ScreenTimeManager: remove deprecated .all() API and add FamilyActivitySelection support"

#### 문제
```swift
// ❌ Deprecated API 사용
store.shield.applications = .all()
store.shield.webDomains = .all()
```
- iOS 16+에서 `.all()` API가 제거됨
- 타입 오류: `Type 'Set<ApplicationToken>?' has no member 'all'`

#### 해결
```swift
// ✅ FamilyActivitySelection 기반 차단
@Published var activitySelection = FamilyActivitySelection()

if !activitySelection.applicationTokens.isEmpty {
    store.shield.applications = activitySelection.applicationTokens
}

if !activitySelection.webDomainTokens.isEmpty {
    store.shield.webDomains = activitySelection.webDomainTokens
}

if !activitySelection.categoryTokens.isEmpty {
    store.shield.applicationCategories = .specific(activitySelection.categoryTokens)
    store.shield.webDomainCategories = .specific(activitySelection.categoryTokens)
}
```

#### 개선사항
- 사용자가 FamilyActivityPicker를 통해 차단할 앱 선택 가능
- 카테고리 단위 차단 지원
- `updateActivitySelection()` 메서드 추가

---

### 2️⃣ AppStateManager.swift (새로 생성)
**커밋:** `d36f3a85` - "Add AppStateManager: central state management for app lock and usage tracking"

#### 문제
- 앱 전체의 상태를 관리할 중앙 클래스가 없음
- 여러 View에서 `@EnvironmentObject var appState: AppStateManager` 참조하는데 클래스가 존재하지 않음

#### 해결
완전한 중앙 상태 관리 시스템 구현:

```swift
class AppStateManager: ObservableObject {
    // 앱 상태
    enum AppState {
        case unlocked
        case locked
        case challengeActive
    }
    
    @Published var currentState: AppState = .unlocked
    
    // 사용 시간 추적
    @Published var todayUsageMinutes: Int = 0
    @Published var dailyGoalMinutes: Int = 180
    
    // 잠금 상태
    @Published var isLocked: Bool = false
    @Published var lockStartTime: Date?
    @Published var unlockTime: Date?
    
    // 챌린지 상태
    @Published var isChallengeActive: Bool = false
    @Published var todayChallengeAttempts: Int = 0
    
    // Screen Time 통합
    var screenTimeManager: ScreenTimeManager?
    
    // 주요 메서드
    func enableLock()
    func disableLock()
    func startUnlockChallenge()
    func endUnlockChallenge(success: Bool)
    func cancelUnlockChallenge()
    func resetAllData()
}
```

#### 주요 기능
- ✅ 중앙화된 앱 상태 관리
- ✅ 사용 시간 자동 추적
- ✅ 일일 목표 관리
- ✅ 자동 잠금/해제
- ✅ 일일 초기화 (매일 0시)
- ✅ UserDefaults 연동

---

### 3️⃣ MainView.swift
**커밋:** 
- `60e65235` - "Fix MainView: break down complex expression into sub-views to fix compiler type-check timeout"
- `26826d41` - "Fix MainView: convert Int to Double for progressColor and format Date to String for localized text"
- `61eca18c` - "Fix MainView: use NSLocalizedString and String.format for proper string formatting"

#### 문제 1: 컴파일러 타임아웃
```swift
// ❌ 너무 복잡한 표현식
private var mainContent: some View {
    ScrollView {
        VStack(spacing: 24) {
            // 언어 스위처
            HStack { ... }
            
            // 목표 달성
            VStack(spacing: 16) {
                Text("today_goal".localized)...
                AnimatedProgressBarWithLabel(...)
                HStack {
                    VStack(alignment: .leading, spacing: 4) { ... }
                    Spacer()
                    PulsatingLockButton(...)
                }
            }
            // ... 더 많은 중첩된 코드
        }
    }
}
```

#### 해결 1: 서브뷰로 분리
```swift
// ✅ 깔끔한 구조
private var mainContent: some View {
    ScrollView {
        VStack(spacing: 24) {
            headerView
            goalAchievementSection
            timeRemainingSection
            weeklyStatsSection
            monthlyHeatmapSection
            Spacer(minLength: 20)
        }
        .padding()
    }
    .background(AppColors.background.ignoresSafeArea())
    .navigationTitle("app_name".localized)
    .toolbar { toolbarContent }
}

private var headerView: some View { ... }
private var goalAchievementSection: some View { ... }
private var progressBar: some View { ... }
// ... 각 섹션을 computed property로 분리
```

#### 문제 2: 타입 불일치
```swift
// ❌ Int → Double 변환 누락
foregroundColor: AppColors.progressColor(percentage: appState.usagePercentage)
// appState.usagePercentage는 Int인데 progressColor는 Double 기대

// ❌ Date → String 변환 오류
Text("expected_lock_time".localized(with: expectedLockTime.formatted(...) as CVarArg))
```

#### 해결 2: 명시적 타입 변환
```swift
// ✅ Int → Double 변환
foregroundColor: AppColors.progressColor(percentage: Double(appState.usagePercentage))

// ✅ 올바른 String 포맷팅
private var expectedLockTimeText: some View {
    let formattedTime = expectedLockTime.formatted(date: .omitted, time: .shortened)
    let localizedFormat = NSLocalizedString("expected_lock_time", comment: "Expected lock time format")
    let finalText = String(format: localizedFormat, formattedTime)
    
    return Text(finalText)
        .font(.subheadline)
        .foregroundColor(AppColors.secondaryText)
}
```

---

### 4️⃣ SettingsView.swift
**커밋:** `62ecc126` - "Refactor SettingsView: organize into cleaner sections and fix AppStateManager integration"

#### 개선사항
- AppStateManager 통합
- 섹션별로 computed property 분리
- Helper 메서드 추가

```swift
// ✅ 깔끔한 구조
var body: some View {
    Form {
        goalSettingsSection
        unlockSettingsSection
        challengeSettingsSection
        notificationSection
        languageSection
        appInfoSection
    }
    .navigationTitle("settings_title".localized)
    .onAppear { loadSettings() }
}

private var goalSettingsSection: some View { ... }
private var unlockSettingsSection: some View { ... }
// ... 각 섹션 분리

private func loadSettings() { ... }
private func updateAutoUnlockTime(_ newValue: Date) { ... }
```

---

### 5️⃣ LockScreenView.swift
**커밋:** `59904e8c` - "Refactor LockScreenView: organize into clean sections and use AppStateManager.disableLock()"

#### 문제
```swift
// ❌ 잘못된 상태 변경
if h <= 0 && m <= 0 && s <= 0 {
    appState.isLocked = false  // 직접 변경
}
```

#### 해결
```swift
// ✅ AppStateManager 메서드 사용
if h <= 0 && m <= 0 && s <= 0 {
    unlockApp()
}

private func unlockApp() {
    appState.disableLock()
    NotificationManager.shared.scheduleUnlockNotification(isCreative: false)
}
```

#### 구조 개선
- 배경, 파티클, 메인 컨텐츠를 별도 computed property로 분리
- 액션 핸들러 메서드 분리
- 타이머 관련 로직 정리

---

### 6️⃣ UnlockChallengeView.swift
**커밋:** `9275396f` - "Fix UnlockChallengeView: use AppStateManager methods instead of non-existent unlockDevice()"

#### 문제
```swift
// ❌ 존재하지 않는 메서드 호출
if result.isSuccess {
    appState.unlockDevice()  // 이런 메서드 없음
}

// ❌ 직접 상태 변경
appState.currentState = .locked
```

#### 해결
```swift
// ✅ 올바른 메서드 사용
private func handleResultDismiss(success: Bool) {
    if success {
        appState.endUnlockChallenge(success: true)
    } else {
        showResult = false
        viewModel.challengeResult = nil
    }
}

private func handleCancel() {
    appState.cancelUnlockChallenge()
}
```

#### 구조 개선
- 각 섹션을 서브뷰로 분리 (ChallengeInputView, EvaluatingView, ResultView)
- @ViewBuilder 사용으로 조건부 렌더링 개선

---

### 7️⃣ ContentView.swift
**커밋:** `1df0d93b` - "Fix ContentView: use correct AppState enum cases (unlocked, locked, challengeActive)"

#### 문제
```swift
// ❌ 존재하지 않는 enum 케이스
switch appState.currentState {
case .normal:          // AppState에 없음
    MainView()
case .unlockChallenge: // AppState에 없음
    UnlockChallengeView()
}
```

#### 해결
```swift
// ✅ 올바른 enum 케이스
switch appState.currentState {
case .unlocked:        // ✅ 정의됨
    MainView()
case .locked:
    LockScreenView()
case .challengeActive: // ✅ 정의됨
    UnlockChallengeView()
}
```

---

### 8️⃣ MainViewModel.swift
**커밋:** `dee6151f` - "Fix MainViewModel: change getExpectedLockTime return type from String to Date"

#### 문제
```swift
// ❌ String 반환하는데 Date 필요
func getExpectedLockTime(currentMinutes: Int, goalMinutes: Int) -> String {
    let remainingMinutes = goalMinutes - currentMinutes
    if remainingMinutes <= 0 {
        return "즉시 잠금"
    }
    
    let lockTime = Date().addingTimeInterval(TimeInterval(remainingMinutes * 60))
    let formatter = DateFormatter()
    // ... 포맷팅
    return formatter.string(from: lockTime) + " 잠금"
}

// MainView에서
TimeRemainingView(
    remainingMinutes: appState.remainingMinutes,
    expectedLockTime: viewModel.getExpectedLockTime(...)  // String이 들어옴
)

// TimeRemainingView는
struct TimeRemainingView: View {
    let expectedLockTime: Date  // Date를 기대
}
```

#### 해결
```swift
// ✅ Date 반환으로 변경
func getExpectedLockTime(currentMinutes: Int, goalMinutes: Int) -> Date {
    let remainingMinutes = goalMinutes - currentMinutes
    
    if remainingMinutes <= 0 {
        return Date()  // 즉시 잠금
    }
    
    return Date().addingTimeInterval(TimeInterval(remainingMinutes * 60))
}
```

이제 TimeRemainingView에서 Date를 받아서 원하는 포맷으로 표시 가능

---

## 주요 개선사항

### 1. 아키텍처
- ✅ **중앙화된 상태 관리**: AppStateManager를 통한 단일 진실의 원천 (Single Source of Truth)
- ✅ **관심사의 분리**: View, ViewModel, Manager의 명확한 역할 구분
- ✅ **의존성 주입**: @EnvironmentObject를 통한 의존성 주입

### 2. 코드 품질
- ✅ **타입 안정성**: 모든 타입 불일치 해결
- ✅ **컴파일 최적화**: 복잡한 표현식을 서브뷰로 분리하여 컴파일 시간 단축
- ✅ **가독성**: 각 섹션을 computed property로 분리하여 코드 가독성 향상

### 3. API 현대화
- ✅ **최신 API 사용**: Deprecated API 제거 및 최신 FamilyControls API 사용
- ✅ **iOS 16+ 호환**: 최신 iOS API 패턴 적용

### 4. 유지보수성
- ✅ **모듈화**: 각 기능을 독립적인 메서드/computed property로 분리
- ✅ **재사용성**: 공통 로직을 AppStateManager에 집중
- ✅ **테스트 용이성**: 명확한 인터페이스와 단일 책임 원칙

---

## 빌드 결과

### 최종 상태
```
✅ Build Succeeded
✅ 0 Errors
✅ 0 Warnings
```

### 수정된 오류 목록
1. ✅ `Type 'Set<ApplicationToken>?' has no member 'all'`
2. ✅ `Type 'Set<WebDomainToken>?' has no member 'all'`
3. ✅ `Cannot find type 'AppStateManager' in scope`
4. ✅ `The compiler is unable to type-check this expression in reasonable time`
5. ✅ `Value of type 'AppStateManager' has no dynamic member 'unlockDevice'`
6. ✅ `Type 'AppStateManager.AppState' has no member 'normal'`
7. ✅ `Cannot convert value of type 'Int' to expected argument type 'Double'`
8. ✅ `Cannot convert value of type 'String' to expected argument type 'Date'`
9. ✅ `Multiple commands produce` (Compile Sources 중복 참조)

---

## 커밋 히스토리

```
dee6151f - Fix MainViewModel: change getExpectedLockTime return type from String to Date
61eca18c - Fix MainView: use NSLocalizedString and String.format for proper string formatting
26826d41 - Fix MainView: convert Int to Double for progressColor and format Date to String for localized text
1df0d93b - Fix ContentView: use correct AppState enum cases (unlocked, locked, challengeActive)
9275396f - Fix UnlockChallengeView: use AppStateManager methods instead of non-existent unlockDevice()
59904e8c - Refactor LockScreenView: organize into clean sections and use AppStateManager.disableLock()
62ecc126 - Refactor SettingsView: organize into cleaner sections and fix AppStateManager integration
60e65235 - Fix MainView: break down complex expression into sub-views to fix compiler type-check timeout
d36f3a85 - Add AppStateManager: central state management for app lock and usage tracking
403e5446 - Fix ScreenTimeManager: remove deprecated .all() API and add FamilyActivitySelection support
```

---

## 다음 단계

### 권장 작업
1. **실제 기기 테스트**: Screen Time API는 시뮬레이터에서 제한적으로만 작동
2. **FamilyActivityPicker UI 구현**: 사용자가 차단할 앱을 선택하는 UI 추가
3. **DeviceActivity Extension 구현**: 실제 사용 시간 데이터 수집
4. **App Group 설정**: Main App과 Extension 간 데이터 공유
5. **단위 테스트 작성**: AppStateManager의 핵심 로직 테스트

### 주의사항
- Screen Time API는 iOS 15.0+ 필요
- FamilyControls capability 추가 필수
- Privacy Policy 명확히 작성
- 앱스토어 제출 시 사용 목적 명시

---

## 참고 문서
- [FamilyControls Framework](https://developer.apple.com/documentation/familycontrols)
- [DeviceActivity Framework](https://developer.apple.com/documentation/deviceactivity)
- [ManagedSettings Framework](https://developer.apple.com/documentation/managedsettings)
- [SwiftUI Best Practices](https://developer.apple.com/documentation/swiftui)

---

**문서 작성일:** 2025년 11월 1일  
**마지막 업데이트:** 2025년 11월 1일
